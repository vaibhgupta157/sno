# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class ietf_inet_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-inet-types - based on the path /ietf-inet-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of generally useful derived
YANG data types for Internet addresses and related things.
Copyright (c) 2013 IETF Trust and the persons identified as
authors of the code.  All rights reserved.
Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(http://trustee.ietf.org/license-info).
This version of this YANG module is part of RFC 6991; see
the RFC itself for full legal notices.
  """
  _pyangbind_elements = {}

  

class yc_commands_sno__devices_device_config_commands(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sno - based on the path /devices/device/config/commands. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__cmd',)

  _yang_name = 'commands'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cmd = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="cmd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'device', 'config', 'commands']

  def _get_cmd(self):
    """
    Getter method for cmd, mapped from YANG variable /devices/device/config/commands/cmd (string)
    """
    return self.__cmd
      
  def _set_cmd(self, v, load=False):
    """
    Setter method for cmd, mapped from YANG variable /devices/device/config/commands/cmd (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cmd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cmd() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="cmd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cmd must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="cmd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='string', is_config=True)""",
        })

    self.__cmd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cmd(self):
    self.__cmd = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="cmd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='string', is_config=True)

  cmd = __builtin__.property(_get_cmd, _set_cmd)


  _pyangbind_elements = OrderedDict([('cmd', cmd), ])


class yc_config_sno__devices_device_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sno - based on the path /devices/device/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__commands',)

  _yang_name = 'config'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__commands = YANGDynClass(base=yc_commands_sno__devices_device_config_commands, is_container='container', yang_name="commands", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'device', 'config']

  def _get_commands(self):
    """
    Getter method for commands, mapped from YANG variable /devices/device/config/commands (container)
    """
    return self.__commands
      
  def _set_commands(self, v, load=False):
    """
    Setter method for commands, mapped from YANG variable /devices/device/config/commands (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_commands is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_commands() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_commands_sno__devices_device_config_commands, is_container='container', yang_name="commands", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """commands must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_commands_sno__devices_device_config_commands, is_container='container', yang_name="commands", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='container', is_config=True)""",
        })

    self.__commands = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_commands(self):
    self.__commands = YANGDynClass(base=yc_commands_sno__devices_device_config_commands, is_container='container', yang_name="commands", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='container', is_config=True)

  commands = __builtin__.property(_get_commands, _set_commands)


  _pyangbind_elements = OrderedDict([('commands', commands), ])


class yc_device_sno__devices_device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sno - based on the path /devices/device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__device_type','__mgmt_ip','__netconf_port','__netconf_user','__netconf_password','__config',)

  _yang_name = 'device'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__device_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)
    self.__mgmt_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)
    self.__netconf_port = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)
    self.__netconf_user = YANGDynClass(base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__netconf_password = YANGDynClass(base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__config = YANGDynClass(base=yc_config_sno__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'device']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/device/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/device/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_device_type(self):
    """
    Getter method for device_type, mapped from YANG variable /devices/device/device_type (enumeration)
    """
    return self.__device_type
      
  def _set_device_type(self, v, load=False):
    """
    Setter method for device_type, mapped from YANG variable /devices/device/device_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_type must be of a type compatible with enumeration""",
          'defined-type': "sno:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)""",
        })

    self.__device_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_type(self):
    self.__device_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)


  def _get_mgmt_ip(self):
    """
    Getter method for mgmt_ip, mapped from YANG variable /devices/device/mgmt_ip (inet:ip-address)
    """
    return self.__mgmt_ip
      
  def _set_mgmt_ip(self, v, load=False):
    """
    Setter method for mgmt_ip, mapped from YANG variable /devices/device/mgmt_ip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_ip() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgmt_ip must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__mgmt_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgmt_ip(self):
    self.__mgmt_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)


  def _get_netconf_port(self):
    """
    Getter method for netconf_port, mapped from YANG variable /devices/device/netconf_port (uint32)
    """
    return self.__netconf_port
      
  def _set_netconf_port(self, v, load=False):
    """
    Setter method for netconf_port, mapped from YANG variable /devices/device/netconf_port (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netconf_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netconf_port() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netconf_port must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)""",
        })

    self.__netconf_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netconf_port(self):
    self.__netconf_port = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)


  def _get_netconf_user(self):
    """
    Getter method for netconf_user, mapped from YANG variable /devices/device/netconf_user (string)
    """
    return self.__netconf_user
      
  def _set_netconf_user(self, v, load=False):
    """
    Setter method for netconf_user, mapped from YANG variable /devices/device/netconf_user (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netconf_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netconf_user() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netconf_user must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__netconf_user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netconf_user(self):
    self.__netconf_user = YANGDynClass(base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_netconf_password(self):
    """
    Getter method for netconf_password, mapped from YANG variable /devices/device/netconf_password (string)
    """
    return self.__netconf_password
      
  def _set_netconf_password(self, v, load=False):
    """
    Setter method for netconf_password, mapped from YANG variable /devices/device/netconf_password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netconf_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netconf_password() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netconf_password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__netconf_password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netconf_password(self):
    self.__netconf_password = YANGDynClass(base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /devices/device/config (container)
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /devices/device/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_sno__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_sno__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_sno__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  device_type = __builtin__.property(_get_device_type, _set_device_type)
  mgmt_ip = __builtin__.property(_get_mgmt_ip, _set_mgmt_ip)
  netconf_port = __builtin__.property(_get_netconf_port, _set_netconf_port)
  netconf_user = __builtin__.property(_get_netconf_user, _set_netconf_user)
  netconf_password = __builtin__.property(_get_netconf_password, _set_netconf_password)
  config = __builtin__.property(_get_config, _set_config)


  _pyangbind_elements = OrderedDict([('name', name), ('device_type', device_type), ('mgmt_ip', mgmt_ip), ('netconf_port', netconf_port), ('netconf_user', netconf_user), ('netconf_password', netconf_password), ('config', config), ])


class yc_groups_sno__devices_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sno - based on the path /devices/groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__device',)

  _yang_name = 'groups'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__device = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'groups']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/groups/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/groups/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_device(self):
    """
    Getter method for device, mapped from YANG variable /devices/groups/device (leafref)
    """
    return self.__device
      
  def _set_device(self, v, load=False):
    """
    Setter method for device, mapped from YANG variable /devices/groups/device (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)""",
        })

    self.__device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device(self):
    self.__device = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  device = __builtin__.property(_get_device, _set_device)


  _pyangbind_elements = OrderedDict([('name', name), ('device', device), ])


class yc_devices_sno__devices(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sno - based on the path /devices. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__device','__groups',)

  _yang_name = 'devices'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__device = YANGDynClass(base=YANGListType("name",yc_device_sno__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)
    self.__groups = YANGDynClass(base=YANGListType("name",yc_groups_sno__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices']

  def _get_device(self):
    """
    Getter method for device, mapped from YANG variable /devices/device (list)
    """
    return self.__device
      
  def _set_device(self, v, load=False):
    """
    Setter method for device, mapped from YANG variable /devices/device (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_device_sno__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_device_sno__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)""",
        })

    self.__device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device(self):
    self.__device = YANGDynClass(base=YANGListType("name",yc_device_sno__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)


  def _get_groups(self):
    """
    Getter method for groups, mapped from YANG variable /devices/groups (list)
    """
    return self.__groups
      
  def _set_groups(self, v, load=False):
    """
    Setter method for groups, mapped from YANG variable /devices/groups (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groups() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_groups_sno__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groups must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_groups_sno__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)""",
        })

    self.__groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groups(self):
    self.__groups = YANGDynClass(base=YANGListType("name",yc_groups_sno__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)

  device = __builtin__.property(_get_device, _set_device)
  groups = __builtin__.property(_get_groups, _set_groups)


  _pyangbind_elements = OrderedDict([('device', device), ('groups', groups), ])


class sno(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sno - based on the path /sno. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__devices',)

  _yang_name = 'sno'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__devices = YANGDynClass(base=yc_devices_sno__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_devices(self):
    """
    Getter method for devices, mapped from YANG variable /devices (container)
    """
    return self.__devices
      
  def _set_devices(self, v, load=False):
    """
    Setter method for devices, mapped from YANG variable /devices (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_devices is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_devices() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_devices_sno__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """devices must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_devices_sno__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)""",
        })

    self.__devices = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_devices(self):
    self.__devices = YANGDynClass(base=yc_devices_sno__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

  devices = __builtin__.property(_get_devices, _set_devices)


  _pyangbind_elements = OrderedDict([('devices', devices), ])


class yc_commands_device__devices_device_config_commands(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /devices/device/config/commands. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__cmd',)

  _yang_name = 'commands'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cmd = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="cmd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'device', 'config', 'commands']

  def _get_cmd(self):
    """
    Getter method for cmd, mapped from YANG variable /devices/device/config/commands/cmd (string)
    """
    return self.__cmd
      
  def _set_cmd(self, v, load=False):
    """
    Setter method for cmd, mapped from YANG variable /devices/device/config/commands/cmd (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cmd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cmd() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="cmd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cmd must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="cmd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='string', is_config=True)""",
        })

    self.__cmd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cmd(self):
    self.__cmd = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="cmd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='string', is_config=True)

  cmd = __builtin__.property(_get_cmd, _set_cmd)


  _pyangbind_elements = OrderedDict([('cmd', cmd), ])


class yc_config_device__devices_device_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /devices/device/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__commands',)

  _yang_name = 'config'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__commands = YANGDynClass(base=yc_commands_device__devices_device_config_commands, is_container='container', yang_name="commands", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'device', 'config']

  def _get_commands(self):
    """
    Getter method for commands, mapped from YANG variable /devices/device/config/commands (container)
    """
    return self.__commands
      
  def _set_commands(self, v, load=False):
    """
    Setter method for commands, mapped from YANG variable /devices/device/config/commands (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_commands is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_commands() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_commands_device__devices_device_config_commands, is_container='container', yang_name="commands", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """commands must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_commands_device__devices_device_config_commands, is_container='container', yang_name="commands", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='container', is_config=True)""",
        })

    self.__commands = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_commands(self):
    self.__commands = YANGDynClass(base=yc_commands_device__devices_device_config_commands, is_container='container', yang_name="commands", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='container', is_config=True)

  commands = __builtin__.property(_get_commands, _set_commands)


  _pyangbind_elements = OrderedDict([('commands', commands), ])


class yc_device_device__devices_device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /devices/device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__device_type','__mgmt_ip','__netconf_port','__netconf_user','__netconf_password','__config',)

  _yang_name = 'device'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__device_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)
    self.__mgmt_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)
    self.__netconf_port = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)
    self.__netconf_user = YANGDynClass(base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__netconf_password = YANGDynClass(base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__config = YANGDynClass(base=yc_config_device__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'device']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/device/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/device/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_device_type(self):
    """
    Getter method for device_type, mapped from YANG variable /devices/device/device_type (enumeration)
    """
    return self.__device_type
      
  def _set_device_type(self, v, load=False):
    """
    Setter method for device_type, mapped from YANG variable /devices/device/device_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_type must be of a type compatible with enumeration""",
          'defined-type': "sno:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)""",
        })

    self.__device_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_type(self):
    self.__device_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)


  def _get_mgmt_ip(self):
    """
    Getter method for mgmt_ip, mapped from YANG variable /devices/device/mgmt_ip (inet:ip-address)
    """
    return self.__mgmt_ip
      
  def _set_mgmt_ip(self, v, load=False):
    """
    Setter method for mgmt_ip, mapped from YANG variable /devices/device/mgmt_ip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_ip() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgmt_ip must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__mgmt_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgmt_ip(self):
    self.__mgmt_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)


  def _get_netconf_port(self):
    """
    Getter method for netconf_port, mapped from YANG variable /devices/device/netconf_port (uint32)
    """
    return self.__netconf_port
      
  def _set_netconf_port(self, v, load=False):
    """
    Setter method for netconf_port, mapped from YANG variable /devices/device/netconf_port (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netconf_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netconf_port() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netconf_port must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)""",
        })

    self.__netconf_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netconf_port(self):
    self.__netconf_port = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)


  def _get_netconf_user(self):
    """
    Getter method for netconf_user, mapped from YANG variable /devices/device/netconf_user (string)
    """
    return self.__netconf_user
      
  def _set_netconf_user(self, v, load=False):
    """
    Setter method for netconf_user, mapped from YANG variable /devices/device/netconf_user (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netconf_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netconf_user() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netconf_user must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__netconf_user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netconf_user(self):
    self.__netconf_user = YANGDynClass(base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_netconf_password(self):
    """
    Getter method for netconf_password, mapped from YANG variable /devices/device/netconf_password (string)
    """
    return self.__netconf_password
      
  def _set_netconf_password(self, v, load=False):
    """
    Setter method for netconf_password, mapped from YANG variable /devices/device/netconf_password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netconf_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netconf_password() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netconf_password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__netconf_password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netconf_password(self):
    self.__netconf_password = YANGDynClass(base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /devices/device/config (container)
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /devices/device/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_device__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_device__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_device__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  device_type = __builtin__.property(_get_device_type, _set_device_type)
  mgmt_ip = __builtin__.property(_get_mgmt_ip, _set_mgmt_ip)
  netconf_port = __builtin__.property(_get_netconf_port, _set_netconf_port)
  netconf_user = __builtin__.property(_get_netconf_user, _set_netconf_user)
  netconf_password = __builtin__.property(_get_netconf_password, _set_netconf_password)
  config = __builtin__.property(_get_config, _set_config)


  _pyangbind_elements = OrderedDict([('name', name), ('device_type', device_type), ('mgmt_ip', mgmt_ip), ('netconf_port', netconf_port), ('netconf_user', netconf_user), ('netconf_password', netconf_password), ('config', config), ])


class yc_groups_device__devices_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /devices/groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__device',)

  _yang_name = 'groups'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__device = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'groups']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/groups/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/groups/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_device(self):
    """
    Getter method for device, mapped from YANG variable /devices/groups/device (leafref)
    """
    return self.__device
      
  def _set_device(self, v, load=False):
    """
    Setter method for device, mapped from YANG variable /devices/groups/device (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)""",
        })

    self.__device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device(self):
    self.__device = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  device = __builtin__.property(_get_device, _set_device)


  _pyangbind_elements = OrderedDict([('name', name), ('device', device), ])


class yc_devices_device__devices(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /devices. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__device','__groups',)

  _yang_name = 'devices'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__device = YANGDynClass(base=YANGListType("name",yc_device_device__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)
    self.__groups = YANGDynClass(base=YANGListType("name",yc_groups_device__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices']

  def _get_device(self):
    """
    Getter method for device, mapped from YANG variable /devices/device (list)
    """
    return self.__device
      
  def _set_device(self, v, load=False):
    """
    Setter method for device, mapped from YANG variable /devices/device (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_device_device__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_device_device__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)""",
        })

    self.__device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device(self):
    self.__device = YANGDynClass(base=YANGListType("name",yc_device_device__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)


  def _get_groups(self):
    """
    Getter method for groups, mapped from YANG variable /devices/groups (list)
    """
    return self.__groups
      
  def _set_groups(self, v, load=False):
    """
    Setter method for groups, mapped from YANG variable /devices/groups (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groups() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_groups_device__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groups must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_groups_device__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)""",
        })

    self.__groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groups(self):
    self.__groups = YANGDynClass(base=YANGListType("name",yc_groups_device__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)

  device = __builtin__.property(_get_device, _set_device)
  groups = __builtin__.property(_get_groups, _set_groups)


  _pyangbind_elements = OrderedDict([('device', device), ('groups', groups), ])


class device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__devices',)

  _yang_name = 'device'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__devices = YANGDynClass(base=yc_devices_device__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_devices(self):
    """
    Getter method for devices, mapped from YANG variable /devices (container)
    """
    return self.__devices
      
  def _set_devices(self, v, load=False):
    """
    Setter method for devices, mapped from YANG variable /devices (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_devices is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_devices() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_devices_device__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """devices must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_devices_device__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)""",
        })

    self.__devices = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_devices(self):
    self.__devices = YANGDynClass(base=yc_devices_device__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

  devices = __builtin__.property(_get_devices, _set_devices)


  _pyangbind_elements = OrderedDict([('devices', devices), ])


class yc_commands_device__devices_device_config_commands(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /devices/device/config/commands. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__cmd',)

  _yang_name = 'commands'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__cmd = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="cmd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'device', 'config', 'commands']

  def _get_cmd(self):
    """
    Getter method for cmd, mapped from YANG variable /devices/device/config/commands/cmd (string)
    """
    return self.__cmd
      
  def _set_cmd(self, v, load=False):
    """
    Setter method for cmd, mapped from YANG variable /devices/device/config/commands/cmd (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cmd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cmd() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="cmd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """cmd must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="cmd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='string', is_config=True)""",
        })

    self.__cmd = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_cmd(self):
    self.__cmd = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="cmd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='string', is_config=True)

  cmd = __builtin__.property(_get_cmd, _set_cmd)


  _pyangbind_elements = OrderedDict([('cmd', cmd), ])


class yc_config_device__devices_device_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /devices/device/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__commands',)

  _yang_name = 'config'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__commands = YANGDynClass(base=yc_commands_device__devices_device_config_commands, is_container='container', yang_name="commands", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'device', 'config']

  def _get_commands(self):
    """
    Getter method for commands, mapped from YANG variable /devices/device/config/commands (container)
    """
    return self.__commands
      
  def _set_commands(self, v, load=False):
    """
    Setter method for commands, mapped from YANG variable /devices/device/config/commands (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_commands is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_commands() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_commands_device__devices_device_config_commands, is_container='container', yang_name="commands", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """commands must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_commands_device__devices_device_config_commands, is_container='container', yang_name="commands", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='container', is_config=True)""",
        })

    self.__commands = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_commands(self):
    self.__commands = YANGDynClass(base=yc_commands_device__devices_device_config_commands, is_container='container', yang_name="commands", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/cumulus-nclu', defining_module='cumulus-nclu', yang_type='container', is_config=True)

  commands = __builtin__.property(_get_commands, _set_commands)


  _pyangbind_elements = OrderedDict([('commands', commands), ])


class yc_device_device__devices_device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /devices/device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__device_type','__mgmt_ip','__netconf_port','__netconf_user','__netconf_password','__config',)

  _yang_name = 'device'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__device_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)
    self.__mgmt_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)
    self.__netconf_port = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)
    self.__netconf_user = YANGDynClass(base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__netconf_password = YANGDynClass(base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__config = YANGDynClass(base=yc_config_device__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'device']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/device/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/device/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_device_type(self):
    """
    Getter method for device_type, mapped from YANG variable /devices/device/device_type (enumeration)
    """
    return self.__device_type
      
  def _set_device_type(self, v, load=False):
    """
    Setter method for device_type, mapped from YANG variable /devices/device/device_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_type must be of a type compatible with enumeration""",
          'defined-type': "sno:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)""",
        })

    self.__device_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_type(self):
    self.__device_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)


  def _get_mgmt_ip(self):
    """
    Getter method for mgmt_ip, mapped from YANG variable /devices/device/mgmt_ip (inet:ip-address)
    """
    return self.__mgmt_ip
      
  def _set_mgmt_ip(self, v, load=False):
    """
    Setter method for mgmt_ip, mapped from YANG variable /devices/device/mgmt_ip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_ip() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgmt_ip must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__mgmt_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgmt_ip(self):
    self.__mgmt_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)


  def _get_netconf_port(self):
    """
    Getter method for netconf_port, mapped from YANG variable /devices/device/netconf_port (uint32)
    """
    return self.__netconf_port
      
  def _set_netconf_port(self, v, load=False):
    """
    Setter method for netconf_port, mapped from YANG variable /devices/device/netconf_port (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netconf_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netconf_port() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netconf_port must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)""",
        })

    self.__netconf_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netconf_port(self):
    self.__netconf_port = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)


  def _get_netconf_user(self):
    """
    Getter method for netconf_user, mapped from YANG variable /devices/device/netconf_user (string)
    """
    return self.__netconf_user
      
  def _set_netconf_user(self, v, load=False):
    """
    Setter method for netconf_user, mapped from YANG variable /devices/device/netconf_user (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netconf_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netconf_user() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netconf_user must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__netconf_user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netconf_user(self):
    self.__netconf_user = YANGDynClass(base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_netconf_password(self):
    """
    Getter method for netconf_password, mapped from YANG variable /devices/device/netconf_password (string)
    """
    return self.__netconf_password
      
  def _set_netconf_password(self, v, load=False):
    """
    Setter method for netconf_password, mapped from YANG variable /devices/device/netconf_password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netconf_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netconf_password() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netconf_password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__netconf_password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netconf_password(self):
    self.__netconf_password = YANGDynClass(base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /devices/device/config (container)
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /devices/device/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_device__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_device__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_device__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  device_type = __builtin__.property(_get_device_type, _set_device_type)
  mgmt_ip = __builtin__.property(_get_mgmt_ip, _set_mgmt_ip)
  netconf_port = __builtin__.property(_get_netconf_port, _set_netconf_port)
  netconf_user = __builtin__.property(_get_netconf_user, _set_netconf_user)
  netconf_password = __builtin__.property(_get_netconf_password, _set_netconf_password)
  config = __builtin__.property(_get_config, _set_config)


  _pyangbind_elements = OrderedDict([('name', name), ('device_type', device_type), ('mgmt_ip', mgmt_ip), ('netconf_port', netconf_port), ('netconf_user', netconf_user), ('netconf_password', netconf_password), ('config', config), ])


class yc_groups_device__devices_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /devices/groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__device',)

  _yang_name = 'groups'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__device = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'groups']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/groups/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/groups/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_device(self):
    """
    Getter method for device, mapped from YANG variable /devices/groups/device (leafref)
    """
    return self.__device
      
  def _set_device(self, v, load=False):
    """
    Setter method for device, mapped from YANG variable /devices/groups/device (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)""",
        })

    self.__device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device(self):
    self.__device = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  device = __builtin__.property(_get_device, _set_device)


  _pyangbind_elements = OrderedDict([('name', name), ('device', device), ])


class yc_devices_device__devices(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /devices. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__device','__groups',)

  _yang_name = 'devices'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__device = YANGDynClass(base=YANGListType("name",yc_device_device__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)
    self.__groups = YANGDynClass(base=YANGListType("name",yc_groups_device__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices']

  def _get_device(self):
    """
    Getter method for device, mapped from YANG variable /devices/device (list)
    """
    return self.__device
      
  def _set_device(self, v, load=False):
    """
    Setter method for device, mapped from YANG variable /devices/device (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_device_device__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_device_device__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)""",
        })

    self.__device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device(self):
    self.__device = YANGDynClass(base=YANGListType("name",yc_device_device__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)


  def _get_groups(self):
    """
    Getter method for groups, mapped from YANG variable /devices/groups (list)
    """
    return self.__groups
      
  def _set_groups(self, v, load=False):
    """
    Setter method for groups, mapped from YANG variable /devices/groups (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groups() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_groups_device__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groups must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_groups_device__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)""",
        })

    self.__groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groups(self):
    self.__groups = YANGDynClass(base=YANGListType("name",yc_groups_device__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)

  device = __builtin__.property(_get_device, _set_device)
  groups = __builtin__.property(_get_groups, _set_groups)


  _pyangbind_elements = OrderedDict([('device', device), ('groups', groups), ])


class device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__devices',)

  _yang_name = 'device'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__devices = YANGDynClass(base=yc_devices_device__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_devices(self):
    """
    Getter method for devices, mapped from YANG variable /devices (container)
    """
    return self.__devices
      
  def _set_devices(self, v, load=False):
    """
    Setter method for devices, mapped from YANG variable /devices (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_devices is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_devices() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_devices_device__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """devices must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_devices_device__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)""",
        })

    self.__devices = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_devices(self):
    self.__devices = YANGDynClass(base=yc_devices_device__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

  devices = __builtin__.property(_get_devices, _set_devices)


  _pyangbind_elements = OrderedDict([('devices', devices), ])


class cumulus_nclu(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module cumulus-nclu - based on the path /cumulus-nclu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  _pyangbind_elements = {}

  


# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
  import builtins as __builtin__
  long = int
elif six.PY2:
  import __builtin__

class ietf_inet_types(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-inet-types - based on the path /ietf-inet-types. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module contains a collection of generally useful derived
YANG data types for Internet addresses and related things.
Copyright (c) 2013 IETF Trust and the persons identified as
authors of the code.  All rights reserved.
Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject
to the license terms contained in, the Simplified BSD License
set forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(http://trustee.ietf.org/license-info).
This version of this YANG module is part of RFC 6991; see
the RFC itself for full legal notices.
  """
  _pyangbind_elements = {}

  

class yc_namespace_ietf_yang_schema_mount__schema_mounts_namespace(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-yang-schema-mount - based on the path /schema-mounts/namespace. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This list provides a mapping of namespace prefixes that are
used in XPath expressions of 'parent-reference' leafs to the
corresponding namespace URI references.
  """
  __slots__ = ('_path_helper', '_extmethods', '__prefix','__uri',)

  _yang_name = 'namespace'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)
    self.__uri = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='inet:uri', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['schema-mounts', 'namespace']

  def _get_prefix(self):
    """
    Getter method for prefix, mapped from YANG variable /schema_mounts/namespace/prefix (yang:yang-identifier)

    YANG Description: Namespace prefix.
    """
    return self.__prefix
      
  def _set_prefix(self, v, load=False):
    """
    Setter method for prefix, mapped from YANG variable /schema_mounts/namespace/prefix (yang:yang-identifier)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_prefix is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_prefix() directly.

    YANG Description: Namespace prefix.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """prefix must be of a type compatible with yang:yang-identifier""",
          'defined-type': "yang:yang-identifier",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)""",
        })

    self.__prefix = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_prefix(self):
    self.__prefix = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="prefix", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)


  def _get_uri(self):
    """
    Getter method for uri, mapped from YANG variable /schema_mounts/namespace/uri (inet:uri)

    YANG Description: Namespace URI reference.
    """
    return self.__uri
      
  def _set_uri(self, v, load=False):
    """
    Setter method for uri, mapped from YANG variable /schema_mounts/namespace/uri (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_uri is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_uri() directly.

    YANG Description: Namespace URI reference.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='inet:uri', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """uri must be of a type compatible with inet:uri""",
          'defined-type': "inet:uri",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='inet:uri', is_config=False)""",
        })

    self.__uri = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_uri(self):
    self.__uri = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="uri", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='inet:uri', is_config=False)

  prefix = __builtin__.property(_get_prefix)
  uri = __builtin__.property(_get_uri)


  _pyangbind_elements = OrderedDict([('prefix', prefix), ('uri', uri), ])


class yc_shared_schema_ietf_yang_schema_mount__schema_mounts_mount_point_shared_schema(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-yang-schema-mount - based on the path /schema-mounts/mount-point/shared-schema. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This node indicates that the server has mounted at least
the module 'ietf-yang-library' at the mount point, and
its instantiation provides the information about the
mounted schema.  When XPath expressions in the mounted
schema are evaluated, the 'parent-reference' leaf-list
is taken into account.
Different instances of the mount point MUST have the
same schema mounted.
  """
  __slots__ = ('_path_helper', '_extmethods', '__parent_reference',)

  _yang_name = 'shared-schema'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__parent_reference = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="parent-reference", parent=self, choice=('schema-ref', 'shared-schema'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:xpath1.0', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['schema-mounts', 'mount-point', 'shared-schema']

  def _get_parent_reference(self):
    """
    Getter method for parent_reference, mapped from YANG variable /schema_mounts/mount_point/shared_schema/parent_reference (yang:xpath1.0)

    YANG Description: Entries of this leaf-list are XPath 1.0 expressions
that are evaluated in the following context:
- The context node is the node in the parent data tree
  where the mount-point is defined.
- The accessible tree is the parent data tree
  *without* any nodes defined in modules that are
  mounted inside the parent schema.
- The context position and context size are both equal
  to 1.
- The set of variable bindings is empty.
- The function library is the core function library
  defined in [XPath] and the functions defined in
  Section 10 of [RFC7950].
- The set of namespace declarations is defined by the
  'namespace' list under 'schema-mounts'.
Each XPath expression MUST evaluate to a nodeset
(possibly empty). For the purposes of evaluating XPath
expressions whose context nodes are defined in the
mounted schema, the union of all these nodesets
together with ancestor nodes are added to the
accessible data tree.
Note that in the case 'ietf-yang-schema-mount' is
itself mounted, a 'parent-reference' in the mounted
module may refer to nodes that were brought into the
accessible tree through a 'parent-reference' in the
parent schema.
    """
    return self.__parent_reference
      
  def _set_parent_reference(self, v, load=False):
    """
    Setter method for parent_reference, mapped from YANG variable /schema_mounts/mount_point/shared_schema/parent_reference (yang:xpath1.0)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parent_reference is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parent_reference() directly.

    YANG Description: Entries of this leaf-list are XPath 1.0 expressions
that are evaluated in the following context:
- The context node is the node in the parent data tree
  where the mount-point is defined.
- The accessible tree is the parent data tree
  *without* any nodes defined in modules that are
  mounted inside the parent schema.
- The context position and context size are both equal
  to 1.
- The set of variable bindings is empty.
- The function library is the core function library
  defined in [XPath] and the functions defined in
  Section 10 of [RFC7950].
- The set of namespace declarations is defined by the
  'namespace' list under 'schema-mounts'.
Each XPath expression MUST evaluate to a nodeset
(possibly empty). For the purposes of evaluating XPath
expressions whose context nodes are defined in the
mounted schema, the union of all these nodesets
together with ancestor nodes are added to the
accessible data tree.
Note that in the case 'ietf-yang-schema-mount' is
itself mounted, a 'parent-reference' in the mounted
module may refer to nodes that were brought into the
accessible tree through a 'parent-reference' in the
parent schema.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="parent-reference", parent=self, choice=('schema-ref', 'shared-schema'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:xpath1.0', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """parent_reference must be of a type compatible with yang:xpath1.0""",
          'defined-type': "yang:xpath1.0",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="parent-reference", parent=self, choice=('schema-ref', 'shared-schema'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:xpath1.0', is_config=False)""",
        })

    self.__parent_reference = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_parent_reference(self):
    self.__parent_reference = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="parent-reference", parent=self, choice=('schema-ref', 'shared-schema'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:xpath1.0', is_config=False)

  parent_reference = __builtin__.property(_get_parent_reference)

  __choices__ = {'schema-ref': {'shared-schema': ['parent_reference']}}
  _pyangbind_elements = OrderedDict([('parent_reference', parent_reference), ])


class yc_mount_point_ietf_yang_schema_mount__schema_mounts_mount_point(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-yang-schema-mount - based on the path /schema-mounts/mount-point. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Each entry of this list specifies a schema for a particular
mount point.
Each mount point MUST be defined using the 'mount-point'
extension in one of the modules listed in the server's
YANG library instance with conformance type 'implement'.
  """
  __slots__ = ('_path_helper', '_extmethods', '__module','__label','__config','__shared_schema',)

  _yang_name = 'mount-point'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__module = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)
    self.__label = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)
    self.__config = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='boolean', is_config=False)
    self.__shared_schema = YANGDynClass(base=yc_shared_schema_ietf_yang_schema_mount__schema_mounts_mount_point_shared_schema, is_container='container', yang_name="shared-schema", parent=self, choice=('schema-ref', 'shared-schema'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='container', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['schema-mounts', 'mount-point']

  def _get_module(self):
    """
    Getter method for module, mapped from YANG variable /schema_mounts/mount_point/module (yang:yang-identifier)

    YANG Description: Name of a module containing the mount point.
    """
    return self.__module
      
  def _set_module(self, v, load=False):
    """
    Setter method for module, mapped from YANG variable /schema_mounts/mount_point/module (yang:yang-identifier)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_module is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_module() directly.

    YANG Description: Name of a module containing the mount point.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """module must be of a type compatible with yang:yang-identifier""",
          'defined-type': "yang:yang-identifier",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)""",
        })

    self.__module = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_module(self):
    self.__module = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="module", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)


  def _get_label(self):
    """
    Getter method for label, mapped from YANG variable /schema_mounts/mount_point/label (yang:yang-identifier)

    YANG Description: Label of the mount point defined using the 'mount-point'
extension.
    """
    return self.__label
      
  def _set_label(self, v, load=False):
    """
    Setter method for label, mapped from YANG variable /schema_mounts/mount_point/label (yang:yang-identifier)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_label is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_label() directly.

    YANG Description: Label of the mount point defined using the 'mount-point'
extension.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """label must be of a type compatible with yang:yang-identifier""",
          'defined-type': "yang:yang-identifier",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)""",
        })

    self.__label = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_label(self):
    self.__label = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '[a-zA-Z_][a-zA-Z0-9\\-_.]*', 'length': ['1..max']}), is_leaf=True, yang_name="label", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='yang:yang-identifier', is_config=False)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /schema_mounts/mount_point/config (boolean)

    YANG Description: If this leaf is set to 'false', then all data nodes in the
mounted schema are read-only (config false), regardless of
their 'config' property.
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /schema_mounts/mount_point/config (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.

    YANG Description: If this leaf is set to 'false', then all data nodes in the
mounted schema are read-only (config false), regardless of
their 'config' property.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='boolean', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with boolean""",
          'defined-type': "boolean",
          'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='boolean', is_config=False)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='boolean', is_config=False)


  def _get_shared_schema(self):
    """
    Getter method for shared_schema, mapped from YANG variable /schema_mounts/mount_point/shared_schema (container)

    YANG Description: This node indicates that the server has mounted at least
the module 'ietf-yang-library' at the mount point, and
its instantiation provides the information about the
mounted schema.  When XPath expressions in the mounted
schema are evaluated, the 'parent-reference' leaf-list
is taken into account.
Different instances of the mount point MUST have the
same schema mounted.
    """
    return self.__shared_schema
      
  def _set_shared_schema(self, v, load=False):
    """
    Setter method for shared_schema, mapped from YANG variable /schema_mounts/mount_point/shared_schema (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shared_schema is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shared_schema() directly.

    YANG Description: This node indicates that the server has mounted at least
the module 'ietf-yang-library' at the mount point, and
its instantiation provides the information about the
mounted schema.  When XPath expressions in the mounted
schema are evaluated, the 'parent-reference' leaf-list
is taken into account.
Different instances of the mount point MUST have the
same schema mounted.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_shared_schema_ietf_yang_schema_mount__schema_mounts_mount_point_shared_schema, is_container='container', yang_name="shared-schema", parent=self, choice=('schema-ref', 'shared-schema'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='container', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """shared_schema must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_shared_schema_ietf_yang_schema_mount__schema_mounts_mount_point_shared_schema, is_container='container', yang_name="shared-schema", parent=self, choice=('schema-ref', 'shared-schema'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='container', is_config=False)""",
        })

    self.__shared_schema = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_shared_schema(self):
    self.__shared_schema = YANGDynClass(base=yc_shared_schema_ietf_yang_schema_mount__schema_mounts_mount_point_shared_schema, is_container='container', yang_name="shared-schema", parent=self, choice=('schema-ref', 'shared-schema'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='container', is_config=False)

  module = __builtin__.property(_get_module)
  label = __builtin__.property(_get_label)
  config = __builtin__.property(_get_config)
  shared_schema = __builtin__.property(_get_shared_schema)

  __choices__ = {'schema-ref': {'shared-schema': ['shared_schema']}}
  _pyangbind_elements = OrderedDict([('module', module), ('label', label), ('config', config), ('shared_schema', shared_schema), ])


class yc_schema_mounts_ietf_yang_schema_mount__schema_mounts(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-yang-schema-mount - based on the path /schema-mounts. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Contains information about the structure of the overall
mounted data model implemented in the server.
  """
  __slots__ = ('_path_helper', '_extmethods', '__namespace','__mount_point',)

  _yang_name = 'schema-mounts'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__namespace = YANGDynClass(base=YANGListType("prefix",yc_namespace_ietf_yang_schema_mount__schema_mounts_namespace, yang_name="namespace", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="namespace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='list', is_config=False)
    self.__mount_point = YANGDynClass(base=YANGListType("module label",yc_mount_point_ietf_yang_schema_mount__schema_mounts_mount_point, yang_name="mount-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='module label', extensions=None), is_container='list', yang_name="mount-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='list', is_config=False)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['schema-mounts']

  def _get_namespace(self):
    """
    Getter method for namespace, mapped from YANG variable /schema_mounts/namespace (list)

    YANG Description: This list provides a mapping of namespace prefixes that are
used in XPath expressions of 'parent-reference' leafs to the
corresponding namespace URI references.
    """
    return self.__namespace
      
  def _set_namespace(self, v, load=False):
    """
    Setter method for namespace, mapped from YANG variable /schema_mounts/namespace (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_namespace is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_namespace() directly.

    YANG Description: This list provides a mapping of namespace prefixes that are
used in XPath expressions of 'parent-reference' leafs to the
corresponding namespace URI references.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("prefix",yc_namespace_ietf_yang_schema_mount__schema_mounts_namespace, yang_name="namespace", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="namespace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """namespace must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("prefix",yc_namespace_ietf_yang_schema_mount__schema_mounts_namespace, yang_name="namespace", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="namespace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='list', is_config=False)""",
        })

    self.__namespace = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_namespace(self):
    self.__namespace = YANGDynClass(base=YANGListType("prefix",yc_namespace_ietf_yang_schema_mount__schema_mounts_namespace, yang_name="namespace", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='prefix', extensions=None), is_container='list', yang_name="namespace", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='list', is_config=False)


  def _get_mount_point(self):
    """
    Getter method for mount_point, mapped from YANG variable /schema_mounts/mount_point (list)

    YANG Description: Each entry of this list specifies a schema for a particular
mount point.
Each mount point MUST be defined using the 'mount-point'
extension in one of the modules listed in the server's
YANG library instance with conformance type 'implement'.
    """
    return self.__mount_point
      
  def _set_mount_point(self, v, load=False):
    """
    Setter method for mount_point, mapped from YANG variable /schema_mounts/mount_point (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mount_point is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mount_point() directly.

    YANG Description: Each entry of this list specifies a schema for a particular
mount point.
Each mount point MUST be defined using the 'mount-point'
extension in one of the modules listed in the server's
YANG library instance with conformance type 'implement'.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("module label",yc_mount_point_ietf_yang_schema_mount__schema_mounts_mount_point, yang_name="mount-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='module label', extensions=None), is_container='list', yang_name="mount-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='list', is_config=False)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mount_point must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("module label",yc_mount_point_ietf_yang_schema_mount__schema_mounts_mount_point, yang_name="mount-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='module label', extensions=None), is_container='list', yang_name="mount-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='list', is_config=False)""",
        })

    self.__mount_point = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mount_point(self):
    self.__mount_point = YANGDynClass(base=YANGListType("module label",yc_mount_point_ietf_yang_schema_mount__schema_mounts_mount_point, yang_name="mount-point", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='module label', extensions=None), is_container='list', yang_name="mount-point", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='list', is_config=False)

  namespace = __builtin__.property(_get_namespace)
  mount_point = __builtin__.property(_get_mount_point)


  _pyangbind_elements = OrderedDict([('namespace', namespace), ('mount_point', mount_point), ])


class ietf_yang_schema_mount(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ietf-yang-schema-mount - based on the path /ietf-yang-schema-mount. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This module defines a YANG extension statement that can be used
to incorporate data models defined in other YANG modules in a
module. It also defines operational state data that specify the
overall structure of the data model.
Copyright (c) 2018 IETF Trust and the persons identified as
authors of the code. All rights reserved.
Redistribution and use in source and binary forms, with or
without modification, is permitted pursuant to, and subject to
the license terms contained in, the Simplified BSD License set
forth in Section 4.c of the IETF Trust's Legal Provisions
Relating to IETF Documents
(https://trustee.ietf.org/license-info).
The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
'MAY', and 'OPTIONAL' in the module text are to be interpreted
as described in BCP 14 [RFC 2119] [RFC8174] when, and only when,
they appear in all capitals, as shown here.
This version of this YANG module is part of RFC XXXX
(https://tools.ietf.org/html/rfcXXXX); see the RFC itself for
full legal notices.
  """
  __slots__ = ('_path_helper', '_extmethods', '__schema_mounts',)

  _yang_name = 'ietf-yang-schema-mount'
  _yang_namespace = 'urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__schema_mounts = YANGDynClass(base=yc_schema_mounts_ietf_yang_schema_mount__schema_mounts, is_container='container', yang_name="schema-mounts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_schema_mounts(self):
    """
    Getter method for schema_mounts, mapped from YANG variable /schema_mounts (container)

    YANG Description: Contains information about the structure of the overall
mounted data model implemented in the server.
    """
    return self.__schema_mounts
      
  def _set_schema_mounts(self, v, load=False):
    """
    Setter method for schema_mounts, mapped from YANG variable /schema_mounts (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_schema_mounts is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_schema_mounts() directly.

    YANG Description: Contains information about the structure of the overall
mounted data model implemented in the server.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_schema_mounts_ietf_yang_schema_mount__schema_mounts, is_container='container', yang_name="schema-mounts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """schema_mounts must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_schema_mounts_ietf_yang_schema_mount__schema_mounts, is_container='container', yang_name="schema-mounts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='container', is_config=True)""",
        })

    self.__schema_mounts = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_schema_mounts(self):
    self.__schema_mounts = YANGDynClass(base=yc_schema_mounts_ietf_yang_schema_mount__schema_mounts, is_container='container', yang_name="schema-mounts", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:ietf:params:xml:ns:yang:ietf-yang-schema-mount', defining_module='ietf-yang-schema-mount', yang_type='container', is_config=True)

  schema_mounts = __builtin__.property(_get_schema_mounts, _set_schema_mounts)


  _pyangbind_elements = OrderedDict([('schema_mounts', schema_mounts), ])


class yc_config_sno__devices_device_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sno - based on the path /devices/device/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__supported_modules',)

  _yang_name = 'config'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__supported_modules = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'device', 'config']

  def _get_supported_modules(self):
    """
    Getter method for supported_modules, mapped from YANG variable /devices/device/config/supported_modules (string)
    """
    return self.__supported_modules
      
  def _set_supported_modules(self, v, load=False):
    """
    Setter method for supported_modules, mapped from YANG variable /devices/device/config/supported_modules (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supported_modules is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supported_modules() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supported_modules must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__supported_modules = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supported_modules(self):
    self.__supported_modules = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)

  supported_modules = __builtin__.property(_get_supported_modules, _set_supported_modules)


  _pyangbind_elements = OrderedDict([('supported_modules', supported_modules), ])


class yc_device_sno__devices_device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sno - based on the path /devices/device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__device_type','__mgmt_ip','__netconf_port','__netconf_user','__netconf_password','__config',)

  _yang_name = 'device'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__device_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)
    self.__mgmt_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)
    self.__netconf_port = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)
    self.__netconf_user = YANGDynClass(base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__netconf_password = YANGDynClass(base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__config = YANGDynClass(base=yc_config_sno__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'device']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/device/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/device/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_device_type(self):
    """
    Getter method for device_type, mapped from YANG variable /devices/device/device_type (enumeration)
    """
    return self.__device_type
      
  def _set_device_type(self, v, load=False):
    """
    Setter method for device_type, mapped from YANG variable /devices/device/device_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_type must be of a type compatible with enumeration""",
          'defined-type': "sno:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)""",
        })

    self.__device_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_type(self):
    self.__device_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)


  def _get_mgmt_ip(self):
    """
    Getter method for mgmt_ip, mapped from YANG variable /devices/device/mgmt_ip (inet:ip-address)
    """
    return self.__mgmt_ip
      
  def _set_mgmt_ip(self, v, load=False):
    """
    Setter method for mgmt_ip, mapped from YANG variable /devices/device/mgmt_ip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_ip() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgmt_ip must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__mgmt_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgmt_ip(self):
    self.__mgmt_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)


  def _get_netconf_port(self):
    """
    Getter method for netconf_port, mapped from YANG variable /devices/device/netconf_port (uint32)
    """
    return self.__netconf_port
      
  def _set_netconf_port(self, v, load=False):
    """
    Setter method for netconf_port, mapped from YANG variable /devices/device/netconf_port (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netconf_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netconf_port() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netconf_port must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)""",
        })

    self.__netconf_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netconf_port(self):
    self.__netconf_port = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)


  def _get_netconf_user(self):
    """
    Getter method for netconf_user, mapped from YANG variable /devices/device/netconf_user (string)
    """
    return self.__netconf_user
      
  def _set_netconf_user(self, v, load=False):
    """
    Setter method for netconf_user, mapped from YANG variable /devices/device/netconf_user (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netconf_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netconf_user() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netconf_user must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__netconf_user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netconf_user(self):
    self.__netconf_user = YANGDynClass(base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_netconf_password(self):
    """
    Getter method for netconf_password, mapped from YANG variable /devices/device/netconf_password (string)
    """
    return self.__netconf_password
      
  def _set_netconf_password(self, v, load=False):
    """
    Setter method for netconf_password, mapped from YANG variable /devices/device/netconf_password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netconf_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netconf_password() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netconf_password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__netconf_password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netconf_password(self):
    self.__netconf_password = YANGDynClass(base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /devices/device/config (container)
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /devices/device/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_sno__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_sno__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_sno__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  device_type = __builtin__.property(_get_device_type, _set_device_type)
  mgmt_ip = __builtin__.property(_get_mgmt_ip, _set_mgmt_ip)
  netconf_port = __builtin__.property(_get_netconf_port, _set_netconf_port)
  netconf_user = __builtin__.property(_get_netconf_user, _set_netconf_user)
  netconf_password = __builtin__.property(_get_netconf_password, _set_netconf_password)
  config = __builtin__.property(_get_config, _set_config)


  _pyangbind_elements = OrderedDict([('name', name), ('device_type', device_type), ('mgmt_ip', mgmt_ip), ('netconf_port', netconf_port), ('netconf_user', netconf_user), ('netconf_password', netconf_password), ('config', config), ])


class yc_groups_sno__devices_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sno - based on the path /devices/groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__device',)

  _yang_name = 'groups'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__device = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'groups']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/groups/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/groups/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_device(self):
    """
    Getter method for device, mapped from YANG variable /devices/groups/device (leafref)
    """
    return self.__device
      
  def _set_device(self, v, load=False):
    """
    Setter method for device, mapped from YANG variable /devices/groups/device (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)""",
        })

    self.__device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device(self):
    self.__device = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  device = __builtin__.property(_get_device, _set_device)


  _pyangbind_elements = OrderedDict([('name', name), ('device', device), ])


class yc_devices_sno__devices(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sno - based on the path /devices. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__device','__groups',)

  _yang_name = 'devices'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__device = YANGDynClass(base=YANGListType("name",yc_device_sno__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)
    self.__groups = YANGDynClass(base=YANGListType("name",yc_groups_sno__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices']

  def _get_device(self):
    """
    Getter method for device, mapped from YANG variable /devices/device (list)
    """
    return self.__device
      
  def _set_device(self, v, load=False):
    """
    Setter method for device, mapped from YANG variable /devices/device (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_device_sno__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_device_sno__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)""",
        })

    self.__device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device(self):
    self.__device = YANGDynClass(base=YANGListType("name",yc_device_sno__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)


  def _get_groups(self):
    """
    Getter method for groups, mapped from YANG variable /devices/groups (list)
    """
    return self.__groups
      
  def _set_groups(self, v, load=False):
    """
    Setter method for groups, mapped from YANG variable /devices/groups (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groups() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_groups_sno__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groups must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_groups_sno__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)""",
        })

    self.__groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groups(self):
    self.__groups = YANGDynClass(base=YANGListType("name",yc_groups_sno__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)

  device = __builtin__.property(_get_device, _set_device)
  groups = __builtin__.property(_get_groups, _set_groups)


  _pyangbind_elements = OrderedDict([('device', device), ('groups', groups), ])


class sno(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module sno - based on the path /sno. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__devices',)

  _yang_name = 'sno'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__devices = YANGDynClass(base=yc_devices_sno__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_devices(self):
    """
    Getter method for devices, mapped from YANG variable /devices (container)
    """
    return self.__devices
      
  def _set_devices(self, v, load=False):
    """
    Setter method for devices, mapped from YANG variable /devices (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_devices is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_devices() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_devices_sno__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """devices must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_devices_sno__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)""",
        })

    self.__devices = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_devices(self):
    self.__devices = YANGDynClass(base=yc_devices_sno__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

  devices = __builtin__.property(_get_devices, _set_devices)


  _pyangbind_elements = OrderedDict([('devices', devices), ])


class yc_config_device__devices_device_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /devices/device/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__supported_modules',)

  _yang_name = 'config'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__supported_modules = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'device', 'config']

  def _get_supported_modules(self):
    """
    Getter method for supported_modules, mapped from YANG variable /devices/device/config/supported_modules (string)
    """
    return self.__supported_modules
      
  def _set_supported_modules(self, v, load=False):
    """
    Setter method for supported_modules, mapped from YANG variable /devices/device/config/supported_modules (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supported_modules is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supported_modules() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supported_modules must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__supported_modules = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supported_modules(self):
    self.__supported_modules = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)

  supported_modules = __builtin__.property(_get_supported_modules, _set_supported_modules)


  _pyangbind_elements = OrderedDict([('supported_modules', supported_modules), ])


class yc_device_device__devices_device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /devices/device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__device_type','__mgmt_ip','__netconf_port','__netconf_user','__netconf_password','__config',)

  _yang_name = 'device'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__device_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)
    self.__mgmt_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)
    self.__netconf_port = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)
    self.__netconf_user = YANGDynClass(base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__netconf_password = YANGDynClass(base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__config = YANGDynClass(base=yc_config_device__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'device']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/device/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/device/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_device_type(self):
    """
    Getter method for device_type, mapped from YANG variable /devices/device/device_type (enumeration)
    """
    return self.__device_type
      
  def _set_device_type(self, v, load=False):
    """
    Setter method for device_type, mapped from YANG variable /devices/device/device_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_type must be of a type compatible with enumeration""",
          'defined-type': "sno:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)""",
        })

    self.__device_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_type(self):
    self.__device_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)


  def _get_mgmt_ip(self):
    """
    Getter method for mgmt_ip, mapped from YANG variable /devices/device/mgmt_ip (inet:ip-address)
    """
    return self.__mgmt_ip
      
  def _set_mgmt_ip(self, v, load=False):
    """
    Setter method for mgmt_ip, mapped from YANG variable /devices/device/mgmt_ip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_ip() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgmt_ip must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__mgmt_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgmt_ip(self):
    self.__mgmt_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)


  def _get_netconf_port(self):
    """
    Getter method for netconf_port, mapped from YANG variable /devices/device/netconf_port (uint32)
    """
    return self.__netconf_port
      
  def _set_netconf_port(self, v, load=False):
    """
    Setter method for netconf_port, mapped from YANG variable /devices/device/netconf_port (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netconf_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netconf_port() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netconf_port must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)""",
        })

    self.__netconf_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netconf_port(self):
    self.__netconf_port = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)


  def _get_netconf_user(self):
    """
    Getter method for netconf_user, mapped from YANG variable /devices/device/netconf_user (string)
    """
    return self.__netconf_user
      
  def _set_netconf_user(self, v, load=False):
    """
    Setter method for netconf_user, mapped from YANG variable /devices/device/netconf_user (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netconf_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netconf_user() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netconf_user must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__netconf_user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netconf_user(self):
    self.__netconf_user = YANGDynClass(base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_netconf_password(self):
    """
    Getter method for netconf_password, mapped from YANG variable /devices/device/netconf_password (string)
    """
    return self.__netconf_password
      
  def _set_netconf_password(self, v, load=False):
    """
    Setter method for netconf_password, mapped from YANG variable /devices/device/netconf_password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netconf_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netconf_password() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netconf_password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__netconf_password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netconf_password(self):
    self.__netconf_password = YANGDynClass(base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /devices/device/config (container)
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /devices/device/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_device__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_device__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_device__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  device_type = __builtin__.property(_get_device_type, _set_device_type)
  mgmt_ip = __builtin__.property(_get_mgmt_ip, _set_mgmt_ip)
  netconf_port = __builtin__.property(_get_netconf_port, _set_netconf_port)
  netconf_user = __builtin__.property(_get_netconf_user, _set_netconf_user)
  netconf_password = __builtin__.property(_get_netconf_password, _set_netconf_password)
  config = __builtin__.property(_get_config, _set_config)


  _pyangbind_elements = OrderedDict([('name', name), ('device_type', device_type), ('mgmt_ip', mgmt_ip), ('netconf_port', netconf_port), ('netconf_user', netconf_user), ('netconf_password', netconf_password), ('config', config), ])


class yc_groups_device__devices_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /devices/groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__device',)

  _yang_name = 'groups'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__device = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'groups']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/groups/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/groups/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_device(self):
    """
    Getter method for device, mapped from YANG variable /devices/groups/device (leafref)
    """
    return self.__device
      
  def _set_device(self, v, load=False):
    """
    Setter method for device, mapped from YANG variable /devices/groups/device (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)""",
        })

    self.__device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device(self):
    self.__device = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  device = __builtin__.property(_get_device, _set_device)


  _pyangbind_elements = OrderedDict([('name', name), ('device', device), ])


class yc_devices_device__devices(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /devices. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__device','__groups',)

  _yang_name = 'devices'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__device = YANGDynClass(base=YANGListType("name",yc_device_device__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)
    self.__groups = YANGDynClass(base=YANGListType("name",yc_groups_device__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices']

  def _get_device(self):
    """
    Getter method for device, mapped from YANG variable /devices/device (list)
    """
    return self.__device
      
  def _set_device(self, v, load=False):
    """
    Setter method for device, mapped from YANG variable /devices/device (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_device_device__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_device_device__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)""",
        })

    self.__device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device(self):
    self.__device = YANGDynClass(base=YANGListType("name",yc_device_device__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)


  def _get_groups(self):
    """
    Getter method for groups, mapped from YANG variable /devices/groups (list)
    """
    return self.__groups
      
  def _set_groups(self, v, load=False):
    """
    Setter method for groups, mapped from YANG variable /devices/groups (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groups() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_groups_device__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groups must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_groups_device__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)""",
        })

    self.__groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groups(self):
    self.__groups = YANGDynClass(base=YANGListType("name",yc_groups_device__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)

  device = __builtin__.property(_get_device, _set_device)
  groups = __builtin__.property(_get_groups, _set_groups)


  _pyangbind_elements = OrderedDict([('device', device), ('groups', groups), ])


class device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__devices',)

  _yang_name = 'device'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__devices = YANGDynClass(base=yc_devices_device__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_devices(self):
    """
    Getter method for devices, mapped from YANG variable /devices (container)
    """
    return self.__devices
      
  def _set_devices(self, v, load=False):
    """
    Setter method for devices, mapped from YANG variable /devices (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_devices is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_devices() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_devices_device__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """devices must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_devices_device__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)""",
        })

    self.__devices = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_devices(self):
    self.__devices = YANGDynClass(base=yc_devices_device__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

  devices = __builtin__.property(_get_devices, _set_devices)


  _pyangbind_elements = OrderedDict([('devices', devices), ])


class yc_config_device__devices_device_config(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /devices/device/config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__supported_modules',)

  _yang_name = 'config'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__supported_modules = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'device', 'config']

  def _get_supported_modules(self):
    """
    Getter method for supported_modules, mapped from YANG variable /devices/device/config/supported_modules (string)
    """
    return self.__supported_modules
      
  def _set_supported_modules(self, v, load=False):
    """
    Setter method for supported_modules, mapped from YANG variable /devices/device/config/supported_modules (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supported_modules is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supported_modules() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """supported_modules must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__supported_modules = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_supported_modules(self):
    self.__supported_modules = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-modules", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)

  supported_modules = __builtin__.property(_get_supported_modules, _set_supported_modules)


  _pyangbind_elements = OrderedDict([('supported_modules', supported_modules), ])


class yc_device_device__devices_device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /devices/device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__device_type','__mgmt_ip','__netconf_port','__netconf_user','__netconf_password','__config',)

  _yang_name = 'device'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__device_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)
    self.__mgmt_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)
    self.__netconf_port = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)
    self.__netconf_user = YANGDynClass(base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__netconf_password = YANGDynClass(base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__config = YANGDynClass(base=yc_config_device__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'device']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/device/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/device/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_device_type(self):
    """
    Getter method for device_type, mapped from YANG variable /devices/device/device_type (enumeration)
    """
    return self.__device_type
      
  def _set_device_type(self, v, load=False):
    """
    Setter method for device_type, mapped from YANG variable /devices/device/device_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_type() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device_type must be of a type compatible with enumeration""",
          'defined-type': "sno:enumeration",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)""",
        })

    self.__device_type = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device_type(self):
    self.__device_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'CumulusLinux': {}, 'odl': {}},), is_leaf=True, yang_name="device_type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='enumeration', is_config=True)


  def _get_mgmt_ip(self):
    """
    Getter method for mgmt_ip, mapped from YANG variable /devices/device/mgmt_ip (inet:ip-address)
    """
    return self.__mgmt_ip
      
  def _set_mgmt_ip(self, v, load=False):
    """
    Setter method for mgmt_ip, mapped from YANG variable /devices/device/mgmt_ip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_ip() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """mgmt_ip must be of a type compatible with inet:ip-address""",
          'defined-type': "inet:ip-address",
          'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)""",
        })

    self.__mgmt_ip = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_mgmt_ip(self):
    self.__mgmt_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="mgmt_ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='inet:ip-address', is_config=True)


  def _get_netconf_port(self):
    """
    Getter method for netconf_port, mapped from YANG variable /devices/device/netconf_port (uint32)
    """
    return self.__netconf_port
      
  def _set_netconf_port(self, v, load=False):
    """
    Setter method for netconf_port, mapped from YANG variable /devices/device/netconf_port (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netconf_port is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netconf_port() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netconf_port must be of a type compatible with uint32""",
          'defined-type': "uint32",
          'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)""",
        })

    self.__netconf_port = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netconf_port(self):
    self.__netconf_port = YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(830), is_leaf=True, yang_name="netconf_port", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='uint32', is_config=True)


  def _get_netconf_user(self):
    """
    Getter method for netconf_user, mapped from YANG variable /devices/device/netconf_user (string)
    """
    return self.__netconf_user
      
  def _set_netconf_user(self, v, load=False):
    """
    Setter method for netconf_user, mapped from YANG variable /devices/device/netconf_user (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netconf_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netconf_user() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netconf_user must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__netconf_user = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netconf_user(self):
    self.__netconf_user = YANGDynClass(base=six.text_type, default=six.text_type("admin"), is_leaf=True, yang_name="netconf_user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_netconf_password(self):
    """
    Getter method for netconf_password, mapped from YANG variable /devices/device/netconf_password (string)
    """
    return self.__netconf_password
      
  def _set_netconf_password(self, v, load=False):
    """
    Setter method for netconf_password, mapped from YANG variable /devices/device/netconf_password (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_netconf_password is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_netconf_password() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """netconf_password must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__netconf_password = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_netconf_password(self):
    self.__netconf_password = YANGDynClass(base=six.text_type, default=six.text_type("CumulusLinux!"), is_leaf=True, yang_name="netconf_password", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_config(self):
    """
    Getter method for config, mapped from YANG variable /devices/device/config (container)
    """
    return self.__config
      
  def _set_config(self, v, load=False):
    """
    Setter method for config, mapped from YANG variable /devices/device/config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_config_device__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """config must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_config_device__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)""",
        })

    self.__config = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_config(self):
    self.__config = YANGDynClass(base=yc_config_device__devices_device_config, is_container='container', yang_name="config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  device_type = __builtin__.property(_get_device_type, _set_device_type)
  mgmt_ip = __builtin__.property(_get_mgmt_ip, _set_mgmt_ip)
  netconf_port = __builtin__.property(_get_netconf_port, _set_netconf_port)
  netconf_user = __builtin__.property(_get_netconf_user, _set_netconf_user)
  netconf_password = __builtin__.property(_get_netconf_password, _set_netconf_password)
  config = __builtin__.property(_get_config, _set_config)


  _pyangbind_elements = OrderedDict([('name', name), ('device_type', device_type), ('mgmt_ip', mgmt_ip), ('netconf_port', netconf_port), ('netconf_user', netconf_user), ('netconf_password', netconf_password), ('config', config), ])


class yc_groups_device__devices_groups(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /devices/groups. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__name','__device',)

  _yang_name = 'groups'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    self.__device = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices', 'groups']

  def _get_name(self):
    """
    Getter method for name, mapped from YANG variable /devices/groups/name (string)
    """
    return self.__name
      
  def _set_name(self, v, load=False):
    """
    Setter method for name, mapped from YANG variable /devices/groups/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
    parent = getattr(self, "_parent", None)
    if parent is not None and load is False:
      raise AttributeError("Cannot set keys directly when" +
                             " within an instantiated list")

    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """name must be of a type compatible with string""",
          'defined-type': "string",
          'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)""",
        })

    self.__name = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_name(self):
    self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='http://example.com/sno', defining_module='sno', yang_type='string', is_config=True)


  def _get_device(self):
    """
    Getter method for device, mapped from YANG variable /devices/groups/device (leafref)
    """
    return self.__device
      
  def _set_device(self, v, load=False):
    """
    Setter method for device, mapped from YANG variable /devices/groups/device (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device must be of a type compatible with leafref""",
          'defined-type': "leafref",
          'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)""",
        })

    self.__device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device(self):
    self.__device = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='http://example.com/sno', defining_module='sno', yang_type='leafref', is_config=True)

  name = __builtin__.property(_get_name, _set_name)
  device = __builtin__.property(_get_device, _set_device)


  _pyangbind_elements = OrderedDict([('name', name), ('device', device), ])


class yc_devices_device__devices(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /devices. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__device','__groups',)

  _yang_name = 'devices'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__device = YANGDynClass(base=YANGListType("name",yc_device_device__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)
    self.__groups = YANGDynClass(base=YANGListType("name",yc_groups_device__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return ['devices']

  def _get_device(self):
    """
    Getter method for device, mapped from YANG variable /devices/device (list)
    """
    return self.__device
      
  def _set_device(self, v, load=False):
    """
    Setter method for device, mapped from YANG variable /devices/device (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_device_device__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """device must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_device_device__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)""",
        })

    self.__device = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_device(self):
    self.__device = YANGDynClass(base=YANGListType("name",yc_device_device__devices_device, yang_name="device", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="device", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)


  def _get_groups(self):
    """
    Getter method for groups, mapped from YANG variable /devices/groups (list)
    """
    return self.__groups
      
  def _set_groups(self, v, load=False):
    """
    Setter method for groups, mapped from YANG variable /devices/groups (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_groups is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_groups() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=YANGListType("name",yc_groups_device__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """groups must be of a type compatible with list""",
          'defined-type': "list",
          'generated-type': """YANGDynClass(base=YANGListType("name",yc_groups_device__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)""",
        })

    self.__groups = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_groups(self):
    self.__groups = YANGDynClass(base=YANGListType("name",yc_groups_device__devices_groups, yang_name="groups", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="groups", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='list', is_config=True)

  device = __builtin__.property(_get_device, _set_device)
  groups = __builtin__.property(_get_groups, _set_groups)


  _pyangbind_elements = OrderedDict([('device', device), ('groups', groups), ])


class device(PybindBase):
  """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module device - based on the path /device. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
  __slots__ = ('_path_helper', '_extmethods', '__devices',)

  _yang_name = 'device'
  _yang_namespace = 'http://example.com/sno'

  _pybind_generated_by = 'container'

  def __init__(self, *args, **kwargs):

    self._path_helper = False

    self._extmethods = False
    self.__devices = YANGDynClass(base=yc_devices_device__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

    load = kwargs.pop("load", None)
    if args:
      if len(args) > 1:
        raise TypeError("cannot create a YANG container with >1 argument")
      all_attr = True
      for e in self._pyangbind_elements:
        if not hasattr(args[0], e):
          all_attr = False
          break
      if not all_attr:
        raise ValueError("Supplied object did not have the correct attributes")
      for e in self._pyangbind_elements:
        nobj = getattr(args[0], e)
        if nobj._changed() is False:
          continue
        setmethod = getattr(self, "_set_%s" % e)
        if load is None:
          setmethod(getattr(args[0], e))
        else:
          setmethod(getattr(args[0], e), load=load)

  def _path(self):
    if hasattr(self, "_parent"):
      return self._parent._path()+[self._yang_name]
    else:
      return []

  def _get_devices(self):
    """
    Getter method for devices, mapped from YANG variable /devices (container)
    """
    return self.__devices
      
  def _set_devices(self, v, load=False):
    """
    Setter method for devices, mapped from YANG variable /devices (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_devices is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_devices() directly.
    """
    if hasattr(v, "_utype"):
      v = v._utype(v)
    try:
      t = YANGDynClass(v,base=yc_devices_device__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)
    except (TypeError, ValueError):
      raise ValueError({
          'error-string': """devices must be of a type compatible with container""",
          'defined-type': "container",
          'generated-type': """YANGDynClass(base=yc_devices_device__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)""",
        })

    self.__devices = t
    if hasattr(self, '_set'):
      self._set()

  def _unset_devices(self):
    self.__devices = YANGDynClass(base=yc_devices_device__devices, is_container='container', yang_name="devices", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='http://example.com/sno', defining_module='sno', yang_type='container', is_config=True)

  devices = __builtin__.property(_get_devices, _set_devices)


  _pyangbind_elements = OrderedDict([('devices', devices), ])


